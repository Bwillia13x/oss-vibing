import type { UIMessageStreamWriter, UIMessage } from 'ai'
import type { DataPart } from '../messages/data-parts'
import { tool } from 'ai'
import description from './export-artifact.md'
import z from 'zod/v3'
import * as fs from 'fs/promises'
import * as path from 'path'
import { jsPDF } from 'jspdf'
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx'
import PptxGenJS from 'pptxgenjs'

interface Params {
  writer: UIMessageStreamWriter<UIMessage<never, DataPart>>
}

// Export document to PDF
async function exportToPDF(docData: any, exportPath: string, options?: any) {
  const doc = new jsPDF()
  
  // Add title
  if (docData.title) {
    doc.setFontSize(20)
    doc.text(docData.title, 20, 20)
  }
  
  // Add author/metadata
  let yPos = 40
  if (docData.author) {
    doc.setFontSize(12)
    doc.text(`Author: ${docData.author}`, 20, yPos)
    yPos += 10
  }
  
  if (docData.date) {
    doc.setFontSize(10)
    doc.text(`Date: ${docData.date}`, 20, yPos)
    yPos += 15
  }
  
  // Add content
  doc.setFontSize(11)
  const content = docData.content || docData.text || 'No content'
  const lines = doc.splitTextToSize(content, 170)
  
  lines.forEach((line: string) => {
    if (yPos > 270) {
      doc.addPage()
      yPos = 20
    }
    doc.text(line, 20, yPos)
    yPos += 7
  })
  
  // Add bibliography if present
  if (docData.bibliography?.formatted) {
    doc.addPage()
    doc.setFontSize(16)
    doc.text('References', 20, 20)
    doc.setFontSize(10)
    
    yPos = 35
    const bibLines = doc.splitTextToSize(docData.bibliography.formatted, 170)
    bibLines.forEach((line: string) => {
      if (yPos > 270) {
        doc.addPage()
        yPos = 20
      }
      doc.text(line, 20, yPos)
      yPos += 6
    })
  }
  
  // Add provenance watermark if requested
  if (options?.includeProvenance && docData.provenance) {
    doc.setFontSize(8)
    doc.setTextColor(150)
    doc.text(
      `Generated by Vibe University - ${new Date().toISOString()}`,
      20,
      285
    )
  }
  
  // Save PDF
  const pdfBuffer = doc.output('arraybuffer')
  await fs.writeFile(exportPath, Buffer.from(pdfBuffer))
}

// Export document to DOCX
async function exportToDOCX(docData: any, exportPath: string, options?: any) {
  const sections: Paragraph[] = []
  
  // Add title
  if (docData.title) {
    sections.push(
      new Paragraph({
        text: docData.title,
        heading: HeadingLevel.TITLE,
      })
    )
  }
  
  // Add metadata
  if (docData.author) {
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: `Author: ${docData.author}`, italics: true })],
      })
    )
  }
  
  if (docData.date) {
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: `Date: ${docData.date}`, italics: true })],
      })
    )
  }
  
  // Add spacing
  sections.push(new Paragraph({ text: '' }))
  
  // Add content
  const content = docData.content || docData.text || 'No content'
  const paragraphs = content.split('\n\n')
  
  paragraphs.forEach((para: string) => {
    sections.push(
      new Paragraph({
        text: para,
      })
    )
  })
  
  // Add bibliography
  if (docData.bibliography?.formatted) {
    sections.push(new Paragraph({ text: '' }))
    sections.push(
      new Paragraph({
        text: 'References',
        heading: HeadingLevel.HEADING_1,
      })
    )
    
    const bibParagraphs = docData.bibliography.formatted.split('\n')
    bibParagraphs.forEach((para: string) => {
      if (para.trim()) {
        sections.push(
          new Paragraph({
            text: para,
          })
        )
      }
    })
  }
  
  // Create document
  const doc = new Document({
    sections: [
      {
        properties: {},
        children: sections,
      },
    ],
  })
  
  // Generate and save
  const buffer = await Packer.toBuffer(doc)
  await fs.writeFile(exportPath, buffer)
}

// Export sheet to CSV
async function exportToCSV(sheetData: any, exportPath: string) {
  const tableName = Object.keys(sheetData.tables)[0]
  const table = sheetData.tables[tableName]
  
  if (!table) {
    throw new Error('No table found in sheet')
  }
  
  // Create CSV content
  const csvLines = []
  
  // Add headers
  csvLines.push(table.headers.join(','))
  
  // Add data rows
  table.data.forEach((row: any[]) => {
    const escapedRow = row.map((cell: any) => {
      const cellStr = String(cell)
      // Escape commas and quotes
      if (cellStr.includes(',') || cellStr.includes('"')) {
        return `"${cellStr.replace(/"/g, '""')}"`
      }
      return cellStr
    })
    csvLines.push(escapedRow.join(','))
  })
  
  await fs.writeFile(exportPath, csvLines.join('\n'))
}

// Export deck to PPTX
async function exportToPPTX(deckData: any, exportPath: string, options?: any) {
  const pptx = new PptxGenJS()
  
  // Set presentation properties
  pptx.author = deckData.author || 'Vibe University'
  pptx.title = deckData.title || 'Presentation'
  pptx.subject = deckData.description || 'Academic Presentation'
  
  // Title slide
  const titleSlide = pptx.addSlide()
  titleSlide.addText(deckData.title || 'Untitled Presentation', {
    x: 0.5,
    y: 1.5,
    w: 9,
    h: 1.5,
    fontSize: 44,
    bold: true,
    align: 'center',
    color: '363636',
  })
  
  if (deckData.author) {
    titleSlide.addText(deckData.author, {
      x: 0.5,
      y: 3.5,
      w: 9,
      h: 0.5,
      fontSize: 20,
      align: 'center',
      color: '666666',
    })
  }
  
  if (deckData.date) {
    titleSlide.addText(deckData.date, {
      x: 0.5,
      y: 4.2,
      w: 9,
      h: 0.4,
      fontSize: 14,
      align: 'center',
      color: '999999',
    })
  }
  
  // Add content slides
  if (deckData.slides && Array.isArray(deckData.slides)) {
    deckData.slides.forEach((slideData: any) => {
      const slide = pptx.addSlide()
      
      // Add slide title
      if (slideData.title) {
        slide.addText(slideData.title, {
          x: 0.5,
          y: 0.5,
          w: 9,
          h: 0.8,
          fontSize: 32,
          bold: true,
          color: '363636',
        })
      }
      
      // Add slide content and bullets, ensuring no overlap
      const hasContent = !!slideData.content
      const hasBullets = slideData.bullets && Array.isArray(slideData.bullets) && slideData.bullets.length > 0
      const baseY = slideData.title ? 1.5 : 0.5

      if (hasContent && hasBullets) {
        // Render content at baseY, bullets below content
        slide.addText(slideData.content, {
          x: 0.5,
          y: baseY,
          w: 9,
          h: 1.2,
          fontSize: 18,
          color: '444444',
          valign: 'top',
        })
        slide.addText(slideData.bullets, {
          x: 1,
          y: baseY + 1.3, // Offset bullets below content
          w: 8,
          h: 3.2,
          fontSize: 16,
          bullet: true,
          color: '444444',
        })
      } else if (hasContent) {
        slide.addText(slideData.content, {
          x: 0.5,
          y: baseY,
          w: 9,
          h: 4.5,
          fontSize: 18,
          color: '444444',
          valign: 'top',
        })
      } else if (hasBullets) {
        slide.addText(slideData.bullets, {
          x: 1,
          y: baseY,
          w: 8,
          h: 4.5,
          fontSize: 16,
          bullet: true,
          color: '444444',
        })
      }
      
      // Add notes if present
      if (slideData.notes) {
        slide.addNotes(slideData.notes)
      }
    })
  }
  
  // Add provenance slide if requested
  if (options?.includeProvenance) {
    const provenanceSlide = pptx.addSlide()
    provenanceSlide.addText('Document Information', {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.8,
      fontSize: 24,
      bold: true,
      color: '363636',
    })
    
    const provenanceText = [
      `Generated by: Vibe University`,
      `Date: ${new Date().toISOString().split('T')[0]}`,
      `Original artifact: ${deckData.title || 'Untitled'}`,
    ]
    
    if (deckData.provenance) {
      provenanceText.push(`Provenance tracking: Enabled`)
    }
    
    provenanceSlide.addText(provenanceText.join('\n'), {
      x: 0.5,
      y: 1.5,
      w: 9,
      h: 3,
      fontSize: 14,
      color: '666666',
    })
  }
  
  // Write to file
  await pptx.writeFile({ fileName: exportPath })
}

// Helper function to escape HTML
function escapeHtml(text: string): string {
  const map: { [key: string]: string } = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  }
  return text.replace(/[&<>"']/g, (char) => map[char])
}

// Export to HTML
async function exportToHTML(docData: any, exportPath: string, options?: any) {
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(docData.title || 'Document')}</title>
  <style>
    body {
      font-family: 'Georgia', serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 {
      font-size: 2.5em;
      margin-bottom: 0.5em;
      color: #2c3e50;
    }
    .metadata {
      color: #666;
      font-style: italic;
      margin-bottom: 2em;
    }
    .content {
      margin: 2em 0;
    }
    .bibliography {
      margin-top: 3em;
      border-top: 2px solid #e0e0e0;
      padding-top: 2em;
    }
    .bibliography h2 {
      font-size: 1.8em;
      color: #2c3e50;
    }
    .provenance {
      margin-top: 3em;
      padding: 1em;
      background-color: #f5f5f5;
      border-left: 4px solid #3498db;
      font-size: 0.9em;
      color: #666;
    }
  </style>
</head>
<body>
`
  
  // Add title
  if (docData.title) {
    html += `  <h1>${escapeHtml(docData.title)}</h1>\n`
  }
  
  // Add metadata
  html += `  <div class="metadata">\n`
  if (docData.author) {
    html += `    <p>Author: ${escapeHtml(docData.author)}</p>\n`
  }
  if (docData.date) {
    html += `    <p>Date: ${escapeHtml(docData.date)}</p>\n`
  }
  html += `  </div>\n`
  
  // Add content
  const content = docData.content || docData.text || 'No content'
  html += `  <div class="content">\n`
  const paragraphs = content.split('\n\n')
  paragraphs.forEach((para: string) => {
    if (para.trim()) {
      html += `    <p>${escapeHtml(para)}</p>\n`
    }
  })
  html += `  </div>\n`
  
  // Add bibliography
  if (docData.bibliography?.formatted) {
    html += `  <div class="bibliography">\n`
    html += `    <h2>References</h2>\n`
    const bibParagraphs = docData.bibliography.formatted.split('\n')
    bibParagraphs.forEach((para: string) => {
      if (para.trim()) {
        html += `    <p>${escapeHtml(para)}</p>\n`
      }
    })
    html += `  </div>\n`
  }
  
  // Add provenance
  if (options?.includeProvenance) {
    html += `  <div class="provenance">\n`
    html += `    <p><strong>Document Information</strong></p>\n`
    html += `    <p>Generated by Vibe University on ${new Date().toISOString()}</p>\n`
    if (docData.provenance) {
      html += `    <p>Provenance tracking: Enabled</p>\n`
    }
    html += `  </div>\n`
  }
  
  html += `</body>
</html>`
  
  await fs.writeFile(exportPath, html)
}

export const exportArtifact = ({ writer }: Params) =>
  tool({
    description,
    inputSchema: z.object({
      artifactPath: z.string().describe('Path to the artifact to export'),
      format: z.enum(['pdf', 'docx', 'pptx', 'csv', 'html', 'mdx']).describe('Export format'),
      options: z.object({
        includeProvenance: z.boolean().optional(),
        watermarkVisible: z.boolean().optional(),
      }).optional().describe('Export options'),
    }),
    execute: async ({ artifactPath, format, options }, { toolCallId }) => {
      writer.write({
        id: toolCallId,
        type: 'data-uni-export',
        data: {
          artifactPath,
          format,
          exportPath: undefined,
          status: 'exporting',
        },
      })

      try {
        // Read artifact
        const fullPath = path.join(process.cwd(), artifactPath)
        const fileContent = await fs.readFile(fullPath, 'utf-8')
        const artifactData = JSON.parse(fileContent)
        
        // Determine export directory and filename
        const exportsDir = path.join(process.cwd(), 'exports')
        await fs.mkdir(exportsDir, { recursive: true })
        
        const fileName = path.basename(artifactPath, path.extname(artifactPath))
        const exportPath = path.join(exportsDir, `${fileName}.${format}`)
        const relativePath = `exports/${fileName}.${format}`
        
        // Export based on format
        switch (format) {
          case 'pdf':
            await exportToPDF(artifactData, exportPath, options)
            break
            
          case 'docx':
            await exportToDOCX(artifactData, exportPath, options)
            break
            
          case 'csv':
            await exportToCSV(artifactData, exportPath)
            break
            
          case 'pptx':
            await exportToPPTX(artifactData, exportPath, options)
            break
            
          case 'html':
            await exportToHTML(artifactData, exportPath, options)
            break
            
          case 'mdx':
            // MDX is just the source format, copy it
            await fs.copyFile(fullPath, exportPath)
            break
            
          default:
            throw new Error(`Unsupported export format: ${format}`)
        }

        writer.write({
          id: toolCallId,
          type: 'data-uni-export',
          data: {
            artifactPath,
            format,
            exportPath: relativePath,
            status: 'done',
          },
        })

        const provenanceNote = options?.includeProvenance ? ' (with provenance metadata)' : ''
        return `Exported ${artifactPath} to ${relativePath} as ${format.toUpperCase()}${provenanceNote}`
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        
        writer.write({
          id: toolCallId,
          type: 'data-uni-export',
          data: {
            artifactPath,
            format,
            exportPath: undefined,
            status: 'error',
            error: { message: errorMessage },
          },
        })
        
        return `Error exporting artifact: ${errorMessage}`
      }
    },
  })
