import type { UIMessageStreamWriter, UIMessage } from 'ai'
import type { DataPart } from '../messages/data-parts'
import { tool } from 'ai'
import description from './export-artifact.md'
import z from 'zod/v3'
import * as fs from 'fs/promises'
import * as path from 'path'
import { jsPDF } from 'jspdf'
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx'

interface Params {
  writer: UIMessageStreamWriter<UIMessage<never, DataPart>>
}

// Export document to PDF
async function exportToPDF(docData: any, exportPath: string, options?: any) {
  const doc = new jsPDF()
  
  // Add title
  if (docData.title) {
    doc.setFontSize(20)
    doc.text(docData.title, 20, 20)
  }
  
  // Add author/metadata
  let yPos = 40
  if (docData.author) {
    doc.setFontSize(12)
    doc.text(`Author: ${docData.author}`, 20, yPos)
    yPos += 10
  }
  
  if (docData.date) {
    doc.setFontSize(10)
    doc.text(`Date: ${docData.date}`, 20, yPos)
    yPos += 15
  }
  
  // Add content
  doc.setFontSize(11)
  const content = docData.content || docData.text || 'No content'
  const lines = doc.splitTextToSize(content, 170)
  
  lines.forEach((line: string) => {
    if (yPos > 270) {
      doc.addPage()
      yPos = 20
    }
    doc.text(line, 20, yPos)
    yPos += 7
  })
  
  // Add bibliography if present
  if (docData.bibliography?.formatted) {
    doc.addPage()
    doc.setFontSize(16)
    doc.text('References', 20, 20)
    doc.setFontSize(10)
    
    yPos = 35
    const bibLines = doc.splitTextToSize(docData.bibliography.formatted, 170)
    bibLines.forEach((line: string) => {
      if (yPos > 270) {
        doc.addPage()
        yPos = 20
      }
      doc.text(line, 20, yPos)
      yPos += 6
    })
  }
  
  // Add provenance watermark if requested
  if (options?.includeProvenance && docData.provenance) {
    doc.setFontSize(8)
    doc.setTextColor(150)
    doc.text(
      `Generated by Vibe University - ${new Date().toISOString()}`,
      20,
      285
    )
  }
  
  // Save PDF
  const pdfBuffer = doc.output('arraybuffer')
  await fs.writeFile(exportPath, Buffer.from(pdfBuffer))
}

// Export document to DOCX
async function exportToDOCX(docData: any, exportPath: string, options?: any) {
  const sections: Paragraph[] = []
  
  // Add title
  if (docData.title) {
    sections.push(
      new Paragraph({
        text: docData.title,
        heading: HeadingLevel.TITLE,
      })
    )
  }
  
  // Add metadata
  if (docData.author) {
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: `Author: ${docData.author}`, italics: true })],
      })
    )
  }
  
  if (docData.date) {
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: `Date: ${docData.date}`, italics: true })],
      })
    )
  }
  
  // Add spacing
  sections.push(new Paragraph({ text: '' }))
  
  // Add content
  const content = docData.content || docData.text || 'No content'
  const paragraphs = content.split('\n\n')
  
  paragraphs.forEach((para: string) => {
    sections.push(
      new Paragraph({
        text: para,
      })
    )
  })
  
  // Add bibliography
  if (docData.bibliography?.formatted) {
    sections.push(new Paragraph({ text: '' }))
    sections.push(
      new Paragraph({
        text: 'References',
        heading: HeadingLevel.HEADING_1,
      })
    )
    
    const bibParagraphs = docData.bibliography.formatted.split('\n')
    bibParagraphs.forEach((para: string) => {
      if (para.trim()) {
        sections.push(
          new Paragraph({
            text: para,
          })
        )
      }
    })
  }
  
  // Create document
  const doc = new Document({
    sections: [
      {
        properties: {},
        children: sections,
      },
    ],
  })
  
  // Generate and save
  const buffer = await Packer.toBuffer(doc)
  await fs.writeFile(exportPath, buffer)
}

// Export sheet to CSV
async function exportToCSV(sheetData: any, exportPath: string) {
  const tableName = Object.keys(sheetData.tables)[0]
  const table = sheetData.tables[tableName]
  
  if (!table) {
    throw new Error('No table found in sheet')
  }
  
  // Create CSV content
  const csvLines = []
  
  // Add headers
  csvLines.push(table.headers.join(','))
  
  // Add data rows
  table.data.forEach((row: any[]) => {
    const escapedRow = row.map((cell: any) => {
      const cellStr = String(cell)
      // Escape commas and quotes
      if (cellStr.includes(',') || cellStr.includes('"')) {
        return `"${cellStr.replace(/"/g, '""')}"`
      }
      return cellStr
    })
    csvLines.push(escapedRow.join(','))
  })
  
  await fs.writeFile(exportPath, csvLines.join('\n'))
}

export const exportArtifact = ({ writer }: Params) =>
  tool({
    description,
    inputSchema: z.object({
      artifactPath: z.string().describe('Path to the artifact to export'),
      format: z.enum(['pdf', 'docx', 'pptx', 'csv', 'html', 'mdx']).describe('Export format'),
      options: z.object({
        includeProvenance: z.boolean().optional(),
        watermarkVisible: z.boolean().optional(),
      }).optional().describe('Export options'),
    }),
    execute: async ({ artifactPath, format, options }, { toolCallId }) => {
      writer.write({
        id: toolCallId,
        type: 'data-uni-export',
        data: {
          artifactPath,
          format,
          exportPath: undefined,
          status: 'exporting',
        },
      })

      try {
        // Read artifact
        const fullPath = path.join(process.cwd(), artifactPath)
        const fileContent = await fs.readFile(fullPath, 'utf-8')
        const artifactData = JSON.parse(fileContent)
        
        // Determine export directory and filename
        const exportsDir = path.join(process.cwd(), 'exports')
        await fs.mkdir(exportsDir, { recursive: true })
        
        const fileName = path.basename(artifactPath, path.extname(artifactPath))
        const exportPath = path.join(exportsDir, `${fileName}.${format}`)
        const relativePath = `exports/${fileName}.${format}`
        
        // Export based on format
        switch (format) {
          case 'pdf':
            await exportToPDF(artifactData, exportPath, options)
            break
            
          case 'docx':
            await exportToDOCX(artifactData, exportPath, options)
            break
            
          case 'csv':
            await exportToCSV(artifactData, exportPath)
            break
            
          case 'html':
          case 'mdx':
          case 'pptx':
            // Placeholder for future implementation
            throw new Error(`Export format ${format} not yet implemented`)
            
          default:
            throw new Error(`Unsupported export format: ${format}`)
        }

        writer.write({
          id: toolCallId,
          type: 'data-uni-export',
          data: {
            artifactPath,
            format,
            exportPath: relativePath,
            status: 'done',
          },
        })

        const provenanceNote = options?.includeProvenance ? ' (with provenance metadata)' : ''
        return `Exported ${artifactPath} to ${relativePath} as ${format.toUpperCase()}${provenanceNote}`
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        
        writer.write({
          id: toolCallId,
          type: 'data-uni-export',
          data: {
            artifactPath,
            format,
            exportPath: undefined,
            status: 'error',
            error: { message: errorMessage },
          },
        })
        
        return `Error exporting artifact: ${errorMessage}`
      }
    },
  })
