import { PriceAdapter, PricePoint } from '../finance/adapters';
import { ChartTask } from '../tasks/router';

export interface SandboxRunner {
  run(
    code: string,
    opts?: { cpuMs?: number; memMb?: number; timeoutMs?: number; allowPackages?: string[] }
  ): Promise<{
    previewUrl: string
    files: string[]
    logs: string[]
    sandboxId?: string
    command?: { cmdId: string; command: string; args: string[] }
  }>;
}

export interface Metrics {
  start(): void;
  stop(): { taskKind: string; model: string; tokens: number; cost: number; latencyMs: number; cacheHit: boolean; providerCalls: { name:string; cost:number }[] };
  label(k:string,v:string|number): void;
}

export async function runChart(
  task: ChartTask,
  deps: { price: PriceAdapter, sandbox: SandboxRunner, metrics: Metrics }
): Promise<{ previewUrl: string; artifacts: string[]; citations: string[]; sandboxId?: string; command?: { cmdId: string; command: string; args: string[] } }> {
  deps.metrics.start();

  // Fetch data
  const dataPromises = task.tickers.map(ticker =>
    deps.price.getPrices({ ticker, range: task.range as any, metric: task.metric })
  );
  const dataSets = await Promise.all(dataPromises);

  // Generate chart code (multi-series + optional drawdowns)
  const chartCode = generateChartCode(task, dataSets);

  // Run in sandbox
  const result = await deps.sandbox.run(chartCode, { allowPackages: ['recharts'] });

  deps.metrics.stop();

  return {
    previewUrl: result.previewUrl,
    artifacts: result.files,
    citations: [`Price data from Polygon API for ${task.tickers.join(', ')}`],
    sandboxId: result.sandboxId,
    command: result.command,
  };
}

function generateChartCode(task: ChartTask, dataSets: PricePoint[][]): string {
  // Merge series by date
  const dates = new Set<string>()
  dataSets.forEach(ds => ds.forEach(p => dates.add(p.t)))
  const byTicker = new Map<string, Map<string, number>>()
  task.tickers.forEach((t, idx) => {
    const map = new Map<string, number>()
    dataSets[idx]?.forEach(p => map.set(p.t, p.v))
    byTicker.set(t, map)
  })

  // Optional drawdowns on first ticker
  let ddByDate: Map<string, number> | null = null
  if (task.flags?.drawdowns && dataSets[0]) {
    const dd = computeDrawdowns(dataSets[0]).reduce<Record<string, number>>((acc, d) => {
      // Fill drawdown percentage at the trough date; simple placement
      acc[d.end] = d.pct
      return acc
    }, {})
    ddByDate = new Map<string, number>(Object.entries(dd))
  }

  const rows: Array<Record<string, string | number>> = []
  Array.from(dates).sort((a, b) => a.localeCompare(b)).forEach(date => {
    const row: Record<string, string | number> = { date }
    for (const t of task.tickers) {
      const v = byTicker.get(t)?.get(date)
      if (typeof v === 'number') row[t] = v
    }
    if (ddByDate?.has(date)) {
      row.drawdown = Number((ddByDate?.get(date) ?? 0).toFixed(4))
    }
    rows.push(row)
  })

  // Emit only the data array; the sandbox runner builds the HTML and renders all series
  const data = rows
  const annotations = Array.isArray(task.flags?.annotations)
    ? task.flags?.annotations
    : []
  return `
// Generated by Mad Lab
const data = ${JSON.stringify(data)};
const annotations = ${JSON.stringify(annotations)};
`
}

export function computeDrawdowns(series: {t:string; v:number}[]): { start: string; end: string; pct: number }[] {
  const results: { start: string; end: string; pct: number }[] = []
  if (series.length === 0) return results
  let peak = series[0]
  let trough = series[0]
  let inDrawdown = false
  for (let i = 1; i < series.length; i++) {
    const p = series[i]
    if (p.v > peak.v) {
      if (inDrawdown) {
        // close previous drawdown at last trough
        const pct = (trough.v - peak.v) / peak.v
        results.push({ start: peak.t, end: trough.t, pct })
        inDrawdown = false
      }
      peak = p
      trough = p
    } else if (p.v < trough.v) {
      trough = p
      inDrawdown = true
    }
  }
  if (inDrawdown) {
    const pct = (trough.v - peak.v) / peak.v
    results.push({ start: peak.t, end: trough.t, pct })
  }
  return results
}
